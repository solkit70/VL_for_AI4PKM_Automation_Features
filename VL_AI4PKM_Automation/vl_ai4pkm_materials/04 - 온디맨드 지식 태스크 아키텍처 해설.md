아래 문서는 블로그 포스트 "On-demand Knowledge Task Processing"(2025-10-20, Jin Kim & Minsuk Kang)을 한국어로 자세히 해설한 학습 노트입니다.
원문: https://jykim.github.io/AI4PKM/blog/2025/10/20/on-demand-knowledge-task.html

> 관련 노트: [[01 - Orchestrator 상세 해설]] · [[02 - Orchestrator 구현 스펙]] · [[03 - Agentic AI 아키텍처 해설]]

## 1) 문제 의식 (Why we built this)
- 기존 배치 실행(batch `ai4pkm`)은 데일리/위클리 요약처럼 “지연 가능” 작업엔 적합했지만, 클리핑 직후 정제·해시태그 추가 등 즉시 피드백이 필요한 지식 태스크에는 부적합.
- 목표:
  1) 파일/이벤트 기반 즉시 처리(on-demand) 파이프라인
  2) 다양한 태스크 유형을 다루는 유연한 구조
  3) 다중 에이전트(Claude, Gemini, Codex) 실행 라우팅
  4) 품질 확보를 위한 평가(Evaluation) 단계 도입

## 2) 초기 프로토타입 한계 (Prompt-based Workflow)
- 첫 시도: 하나의 큰 프롬프트 체인(UKTP)으로 생성→처리→평가 연결.
- 문제:
  - 프롬프트 장황·명령 누락 발생(지시사항 자주 어김)
  - 수동/배치 실행으로 실시간성이 없음
  - 구조적 상태 추적 부족(세부 단계 실패 원인 파악 어려움)

→ 해결 방향: 프롬프트 한 덩어리 대신 “단계화된 실행 파이프라인 + 상태 관리 + 이벤트 감시” 구조.

## 3) 온디맨드 태스크 실행 시스템 개요 (On-demand Task Execution System)
세 가지 역할/단계로 분리:

| 단계 | 컴포넌트 | 책임 | 상태 전이 기여 |
|------|----------|------|----------------|
| 생성(Generation) | KTG (Knowledge Task Generator) | 트리거 이벤트 감지 후 구조화된 태스크 파일 생성 | (없음 → TBD) |
| 실행(Processing) | KTP (Knowledge Task Processor) | 태스크를 적절한 에이전트에 라우팅·모니터링 | TBD → IN_PROGRESS → PROCESSED |
| 평가(Evaluation) | KTE (Knowledge Task Evaluator) | 출력 검증·마이너 수정·품질 향상 | PROCESSED → UNDER_REVIEW → COMPLETED/FAILED |

추가 개념:
- 파일시스템 감시 → 트리거 분류 → 생성된 태스크는 Markdown 메타데이터(frontmatter)로 상태/담당 에이전트/입출력 정보를 포함.
- 각 단계 별 로그(감사 트레일)로 가시성 확보.

## 4) 트리거(Trigger) 유형
사용자가 다양한 방식으로 태스크 생성:

| 트리거 행위 | 예시 마커/행동 | 매핑 태스크 유형 |
|-------------|---------------|------------------|
| 웹 클리핑 추가 | 새 파일 유입 (Clippings 폴더) | EIC (Enrich Ingested Content) |
| 음성 입력(Limitless pendant) | “Hey PKM” 후 명령 | 음성 명령 태스크 (예: 요약 요청) |
| 노트 편집 해시태그 | `#AI` 추가 | 해시태그 기반 태스크 생성 |
| 기타 마커 | 특정 구문 / 규칙 | 맞춤형 생성 라우팅 |

트리거 감지 후 KTG가 표준화된 태스크 파일을 `_Settings_/Tasks` 또는 `AI/Tasks` (문서 예시) 경로에 생성.

## 5) 태스크 파일 구조 (Markdown as DB)
Frontmatter 예시(개념적):

```
---
title: Enrich Ingested Content (EIC)
status: TBD            # TBD | IN_PROGRESS | PROCESSED | UNDER_REVIEW | COMPLETED | FAILED
agent: Gemini          # 실행 단계에서 선택된 에이전트
priority: normal
created: 2025-10-20T12:34:56Z
last_update: 2025-10-20T12:35:10Z
source_path: Ingest/Clippings/2025-10-20-clip.md
output_path: AI/Articles/2025-10-20-clip-enriched.md
generation_log: [...]
execution_log: [...]
evaluation_log: [...]
---
(본문: 원본 발췌, 요구되는 변환 규칙, 품질 체크리스트 등)
```

장점:
- 투명성: 상태/로그를 한 파일 내에 축적
- 감사 추적: 인과 관계(어떤 에이전트·언제·무엇을 수정)
- 간편한 인간 개입: 필요 시 수동 편집·재실행 플래그 설정 가능

## 6) 실행 파이프라인 상세

1) 생성(Generation)
   - 트리거 이벤트 소비
   - 태스크 모델 도출 (타입·입력·초기 상태)
   - 파일 생성(TBD)

2) 실행(Processing)
   - 라우팅 규칙: `ai4pkm_cli.json`에서 “태스크 타입 → 에이전트” 매핑 (예: Research→Gemini, Enrichment→Claude)
   - 동시성/타임아웃 설정도 여기 반영
   - 상태 IN_PROGRESS로 업데이트
   - 에이전트 호출(프롬프트 조립 + 입력 전달) → 완료 시 산출물 기록 → 상태 PROCESSED

3) 평가(Evaluation)
   - 별도 에이전트(또는 동일하지만 다른 프롬프트)로 품질 검증
   - 구조/요약/표현 오류 교정, 태그 보강
   - 상태 UNDER_REVIEW → COMPLETED (실패 시 FAILED)
   - 필요하면 재시도/수동 개입

데이터 흐름(문자 다이어그램):

```
Trigger (clip/#AI/voice) 
  → KTG: Task.md (status=TBD)
    → KTP: Execute agent (status=IN_PROGRESS → PROCESSED)
      → KTE: Evaluate/fix (status=UNDER_REVIEW → COMPLETED/FAILED)
```

## 7) 설정 파일 `ai4pkm_cli.json` 역할
- 태스크 타입별 실행 에이전트 매핑
- 평가 담당 에이전트 지정
- 동시성 제한(전역/타입별)
- 타임아웃(분)·재시도 정책(있다면)
- 장점: 단일 JSON로 빠른 실험 가능 (후속 세대에서 YAML+노드 기반으로 진화)

## 8) 상태(State) 라이프사이클
| 상태 | 의미 | 전이 조건 |
|------|------|-----------|
| TBD | 새로 생성됨 | 실행기(KTP)가 픽업 |
| IN_PROGRESS | 에이전트가 처리 중 | 정상 완료 → PROCESSED / 오류 → FAILED |
| PROCESSED | 1차 산출물 생성 | 평가 에이전트 시작 → UNDER_REVIEW |
| UNDER_REVIEW | 품질검수/교정 중 | 완료 → COMPLETED / 실패 → FAILED |
| COMPLETED | 최종 완료 | 종단 |
| FAILED | 오류 또는 품질 불충분 | 재시도/개입 가능 |

## 9) 예시 워크플로: 클리핑 풍부화(EIC)
- 웹 클리퍼로 YouTube transcript 저장 → 새 파일 이벤트 → KTG 태스크 생성(TBD)
- 콘솔: KTP가 태스크 잡음(IN_PROGRESS, agent=Gemini)
- 실행 종료 → PROCESSED (산출물 요약·핵심 포인트 생성)
- KTE 개입 → UNDER_REVIEW → 품질 통과 → COMPLETED (최종 개선본 확인 가능)

## 10) 학습(Logging & Human-in-the-Loop)
- 단계별 로그 분리: generation_log / execution_log / evaluation_log
- 사용자는 진행 상황·실패 지점 파악 가능
- “자동화는 인간 판단을 증폭” 원칙: 품질 개선·편향 수정·컨텍스트 보강은 사람 개입 여지 유지

## 11) 다중 에이전트 전략 (Heterogeneous Ecosystem)
- 태스크 특성별 최적 에이전트 선택(연구=Gemini, 코드 품질=Claude Code 등)
- 비용·속도·정확도 기준의 라우팅 정책 가능
- 동일 태스크를 복수 에이전트에 병렬 보내어 결과 비교(중요 태스크 품질 향상)

## 12) 교차 평가(Multi-Agent Evaluation)
- 실행 에이전트 ≠ 평가 에이전트 → 자기 출력 자기 검수의 문맥 포화(context overflow) 문제 감소
- 서로 다른 모델 강점 활용: 생성 전문 / 평가 전문 분업

## 13) 분리(Separation) 철학: Script vs Agent
- 반복 가능·결정적 작업(파일 감시, 상태 플래그 갱신)은 스크립트
- 고차적 언어·요약·추론은 에이전트
- 결과: 안정성↑ 디버깅 용이↑ 에이전트 토큰 낭비↓  

## 14) 한계(Limitations)
| 영역 | 한계 | 영향 |
|------|------|------|
| 구성 유연성 | JSON 중심, 노드/패턴·내용 매칭 미흡 | 세밀 트리거 어렵다 |
| 실시간성 | 폴링/단순 감시 전략 | 스케일 상승 시 이벤트 누락/지연 가능 |
| 확장성 | 프롬프트-에이전트 결합 강함 | 공유·마켓 생태계 구축 난이도 |
| 품질 확보 | 평가 규칙 단순 | 고도화된 구조 검사(레이블링 등) 부족 |
| 실패 복구 | 에러/중단 태스크 재시스템화 제한 | 수동 개입 필요 증가 |
| 메트릭 | 성능/품질 수집 체계 부족 | 최적화·튜닝 근거 약함 |

## 15) 개선 아이디어(당시 관점)
- 구성: YAML 노드 기반, 트리거 패턴·내용 정규식 지원
- 동시성: 글로벌+에이전트별 이중 제어
- 태스크 파일: 표준 Frontmatter + 감시/큐 처리
- 평가: 구조화된 품질 체크리스트 도입
- 메트릭: 처리 지연, 실패율, 재시도 횟수 수집
- 생태계: 공유 가능한 “Skills” 추상화

## 16) 신형(Agentic Architecture) 대비 주요 차이
| 항목 | 온디맨드(구) | Agentic(신) | 효과 |
|------|--------------|-------------|------|
| 구성 포맷 | 단일 JSON | YAML nodes + 프롬프트 | 선언성·확장성 향상 |
| 에이전트 정의 | 코드/라우팅 분리 | 프롬프트가 1차 정의 | 사용자 생성 쉬움 |
| 트리거 매칭 | 기본 파일 이벤트 | 패턴/내용 정규식 | 세밀 제어 가능 |
| 동시성 | 단층 혹은 제한적 | 글로벌+에이전트 이중 | 안정적 부하 관리 |
| 평가 구조 | 실행 후 단순 교정 | 후처리/평가 확장 지향 | 품질 파이프라인 강화 |
| UX | CLI 중심 | Mac App + 음성 + CLI | 비개발자 접근성 극대화 |
| 생태계 | 내부 사용 중심 | 공유/커스터마이즈 지향 | 커뮤니티 확장 |

## 17) 마이그레이션 관점
- 태스크 파일 포맷 유지 → 기존 기록 자산 활용 가능
- 라우팅 규칙을 JSON → YAML로 이전 (필드 매핑 표준화)
- 평가/후처리 재정의: 노드 레벨 옵션(post_process_action 등) 도입
- 점진 전략: 먼저 가장 빈도 높은 태스크(EIC)만 신형으로 이동 후 안정화 → 나머지 확장

## 18) 핵심 교훈(Lessons Learned) 요약
1. 분업(Script vs Agent)이 안정성과 디버깅 용이성 확보에 중요.
2. 인간 판단(Human-in-the-Loop) 유지가 품질·신뢰도 향상.
3. 교차 평가(Multi-Agent Evaluation)가 출력 오류 감소.
4. 다중 에이전트 전략(Heterogeneous Ecosystem)이 비용·품질 최적화.
5. 이벤트 → 생성 → 실행 → 평가 3+1단계 파이프라인이 재사용성 높음.

## 19) 요약(Recap)
- 온디맨드 아키텍처는 “이벤트 기반 태스크 생성 + 단계적 처리 + 평가” 기본 패턴을 확립.
- 한계를 계승·해소하면서 신형 Agentic 구조로 확장(구성 선언성·트리거 정밀성·UX·생태계).
- 현재 문서화된 새 아키텍처(01,02,03 노트) 이해를 위한 역사적 토대.
